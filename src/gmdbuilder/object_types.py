"""Object TypedDict definitions"""

# IMPORTANT: the 'a' suffix is a workaround for type safety.
# 
# These types are autogenerated through a 3 step process. 
# Read build_tools for autogeneration scripts

from typing import SupportsIndex, Any, cast

from gmdbuilder.mappings.obj_prop import ObjProp
from gmdbuilder.validation import validate, validate_obj
from gmdbuilder.object_typeddict import ObjectType, MoveType, RotateType, AdvFollowType


ID_TO_TYPEDDICT = {
    901: MoveType,
    1346: RotateType,
    3016: AdvFollowType,
}

class Object(dict[str, Any]):
    """
    Note: Not for users to call directly
    
    The actual dict implementation hidden behind the ObjectType TypedDict
    
    This is to intercept & validate mutations of objects and add new helpers.
    """
    __slots__ = ("_obj_id",)

    def __init__(self, obj_id: int):
        super().__init__()
        self._obj_id = int(obj_id)
        super().__setitem__("a1", self._obj_id)

    def __setitem__(self, k: str, v: Any):
        validate(self._obj_id, k, v)
        if k == ObjProp.ID:
            self._obj_id = int(v)
        super().__setitem__(k, v)

    def update(self, *args: Any, **kwargs: Any):  # type: ignore[override]
        # Construct items dict from args and kwargs
        items: dict[str, Any]
        if args:
            if len(args) != 1:
                raise TypeError(f"update() takes at most 1 positional argument ({len(args)} given)")
            __m = args[0]
            items = dict(__m)  # type: ignore[arg-type]
            items.update(kwargs)
        else:
            items = dict(kwargs)
        
        for k, v in items.items():
            validate(self._obj_id, k, v)
        if ObjProp.ID in items:
            self._obj_id = int(items[ObjProp.ID])
        super().update(items)


class ObjectList(list[ObjectType]):
    """
    A list that validates ObjectType mutations .
    
    - append/insert/extend: wraps objects in ValidatedObject for runtime validation
    - Direct indexing (objects[i]): read-only access to avoid validation overhead
    - Property edits (objects[i]['a2'] = x): validated by ValidatedObject.__setitem__
    - Addition operators (+, +=): disabled - use extend() instead
    """
    
    @staticmethod
    def _wrap_object(obj: ObjectType) -> ObjectType:
        """Wrap an object in ValidatedObject for runtime validation."""
        if isinstance(obj, Object):
            return cast(ObjectType, obj)
        validate_obj(obj)
        wrapped = Object(obj[ObjProp.ID])
        wrapped.update(obj)
        return cast(ObjectType, wrapped)
    
    def __setitem__(self, # type: ignore[override]
        index: SupportsIndex | slice, 
        value: ObjectType | list[ObjectType]):
        """Validate when setting an item by index."""
        if isinstance(index, slice):
            if not isinstance(value, list):
                raise TypeError(f"can only assign a list (not {type(value).__name__}) to a slice")
            validated = [self._wrap_object(obj) for obj in value]
            super().__setitem__(index, validated)
        else:
            if not isinstance(value, dict):
                raise TypeError(f"can only assign ObjectType dict (not {type(value).__name__})")
            validated = self._wrap_object(value)
            super().__setitem__(index, validated)
    
    def append(self, obj: ObjectType, *, bypass_validation: bool = False):
        """Validate and append an object."""
        if bypass_validation:
            super().append(obj)
        else:
            super().append(self._wrap_object(obj))
    
    def insert(self, index: SupportsIndex, obj: ObjectType):
        """Validate and insert an object at index."""
        super().insert(index, self._wrap_object(obj))
    
    def extend(self, iterable: list[ObjectType]):  # type: ignore[override]
        """Validate and extend with multiple objects."""
        validated = [self._wrap_object(obj) for obj in iterable]
        super().extend(validated)
    
    def __add__(self, other: object) -> "ObjectList":  # type: ignore[override]
        """Disabled: use extend() instead for efficiency."""
        raise NotImplementedError("Use .extend() instead of + operator")
    
    def __iadd__(self, other: object) -> "ObjectList":  # type: ignore[override]
        """Disabled: use extend() instead for efficiency."""
        raise NotImplementedError("Use .extend() instead of += operator")
