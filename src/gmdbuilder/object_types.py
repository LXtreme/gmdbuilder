"""Object TypedDict definitions"""

# IMPORTANT: the 'a' suffix is a workaround for type safety.
# 
# These types are autogenerated through a 3 step process. 
# Read build_tools for autogeneration scripts

from typing import Callable, SupportsIndex, Any, cast

from gmdbuilder.mappings.obj_id import ObjId
from gmdbuilder.mappings.obj_prop import ObjProp
from gmdbuilder.validation import validate, validate_obj
import gmdbuilder.object_typeddict as td
ObjectType = td.ObjectType


id = ObjId.Trigger
ID_TO_TYPEDDICT = {
    id.ALPHA: td.AlphaType,
    id.ANIMATE: td.AnimateType,
    id.ANIMATE_KEYFRAME: td.AnimateKeyframeType,
    id.ARROW: td.ArrowType,
    id.BPM: td.BpmType,
    id.ADV_FOLLOW: td.AdvFollowType,
    id.ADV_RANDOM: td.AdvRandomType,
    id.COUNT: td.CountType,
    id.COLOR: td.ColorType,
    id.COLLISION: td.CollisionType,
    id.EDIT_ADV_FOLLOW: td.EditAdvFollowType,
    id.END: td.EndType,
    id.FOLLOW: td.FollowType,
    id.FOLLOW_PLAYER_Y: td.FollowPlayerYType,
    id.GRADIENT: td.GradientType,
    id.GRAVITY: td.GravityType,
    id.INSTANT_COLLISION: td.InstantCollisionType,
    id.INSTANT_COUNT: td.InstantCountType,
    id.ITEM_COMPARE: td.ItemCompareType,
    id.ITEM_EDIT: td.ItemEditType,
    id.ITEM_PERSIST: td.ItemPersistType,
    id.KEYFRAME: td.KeyframeType,
    id.MOVE: td.MoveType,
    id.PICKUP: td.PickupType,
    id.ROTATE: td.RotateType,
    id.STOP: td.StopType,
    id.SCALE: td.ScaleType,
    id.SPAWN: td.SpawnType,
    id.SFX: td.SfxType,
    id.ON_DEATH: td.OnDeathType,
    id.OPTIONS: td.OptionsType,
    id.OFFSET_CAMERA: td.OffsetCameraType,
    id.GAMEPLAY_OFFSET: td.GameplayOffsetType,
    id.LINK_VISIBLE: td.LinkVisibleType,
    id.CHANGE_BG: td.ChangeBgType,
    id.CHANGE_GR: td.ChangeGrType,
    id.CHANGE_MG: td.ChangeMgType,
    id.TELEPORT: td.TeleportType,
    id.TIME: td.TimeType,
    id.TIMEWARP: td.TimewarpType,
    id.TIME_CONTROL: td.TimeControlType,
    id.TIME_EVENT: td.TimeEventType,
    id.TOGGLE: td.ToggleType,
    id.TOGGLE_BLOCK: td.ToggleBlockType,
    id.UI: td.UiType,
    id.ZOOM_CAMERA: td.ZoomCameraType
}
"""Unfinished mapping of Object IDs to non-common Object TypedDicts"""

class Object(dict[str, Any]):
    """
    Note: Not for users to call directly
    
    The actual dict implementation hidden behind the ObjectType TypedDict
    
    This is to intercept & validate mutations of objects and add new helpers.
    """
    __slots__ = ("_obj_id",)

    def __init__(self, obj_id: int):
        super().__init__()
        self._obj_id = int(obj_id)
        super().__setitem__("a1", self._obj_id)

    def __setitem__(self, k: str, v: Any):
        validate(self._obj_id, k, v)
        if k == ObjProp.ID:
            self._obj_id = int(v)
        super().__setitem__(k, v)

    def update(self, *args: Any, **kwargs: Any):  # type: ignore[override]
        # Construct items dict from args and kwargs
        items: dict[str, Any]
        if args:
            if len(args) != 1:
                raise TypeError(f"update() takes at most 1 positional argument ({len(args)} given)")
            __m = args[0]
            items = dict(__m)  # type: ignore[arg-type]
            items.update(kwargs)
        else:
            items = dict(kwargs)
        
        for k, v in items.items():
            validate(self._obj_id, k, v)
        if ObjProp.ID in items:
            self._obj_id = int(items[ObjProp.ID])
        super().update(items)

ObjectPatternMatch = dict[str, Any] | ObjectType | Callable[[ObjectType], bool]

class ObjectList(list[ObjectType]):
    """
    A list that validates ObjectType mutations.
    Only additions are allowed in live editor mode
    
    - append/insert/extend: wraps objects in ValidatedObject for runtime validation
    - Direct indexing (objects[i]): read-only access
    - Property edits (objects[i]['a2'] = x): validated by ValidatedObject.__setitem__
    - Addition operators (+, +=): disabled - use extend() instead
    """
    _MISSING = object()
    
    def __init__(self, *, live_editor: bool):
        super().__init__()
        self._live_editor_mode = live_editor
        self.added_objects: list[ObjectType] = []
    
    def delete_where(self, condition: ObjectPatternMatch, *, limit: int = -1) -> int:
        """
        Delete objects matching a condition (dict or predicate)
        
        Returns number of deleted objects.
        
        For dict-matching, dict must match standard ObjectType keys/values.
        'None' can be used as a wildcard value (not key).
        """
        if self._live_editor_mode:
            raise RuntimeError("Direct object deleting is not allowed in live editor mode")
        if limit < -1 or limit == 0:
            raise ValueError("delete_where limit must be -1 (no limit) or positive")
        predicate: Callable[[ObjectType], bool]
        if isinstance(condition, dict):
            predicate = lambda obj: all(obj.get(k, self._MISSING) == v for k, v in condition.items())
        else:
            predicate = condition
        
        deleted = 0
        
        for i in range(len(self) - 1, -1, -1):
            if predicate(self[i]):
                del self[i]
                deleted += 1
                if limit != -1 and deleted >= limit:
                    break
        
        return deleted
    
    @staticmethod
    def _wrap_object(obj: ObjectType) -> ObjectType:
        """Wrap an object in ValidatedObject for runtime validation."""
        if isinstance(obj, Object):
            return cast(ObjectType, obj)
        validate_obj(obj)
        wrapped = Object(obj[ObjProp.ID])
        wrapped.update(obj)
        return cast(ObjectType, wrapped)
    
    def __setitem__(self, # type: ignore[override]
        index: SupportsIndex | slice, 
        value: ObjectType | list[ObjectType]):
        """Validate when setting an item by index."""
        if self._live_editor_mode:
            raise RuntimeError("Direct object editing is not supported in live editor mode")
        if isinstance(index, slice):
            if not isinstance(value, list):
                raise TypeError(f"can only assign a list (not {type(value).__name__}) to a slice")
            validated = [self._wrap_object(obj) for obj in value]
            super().__setitem__(index, validated)
        else:
            if not isinstance(value, dict):
                raise TypeError(f"can only assign ObjectType dict (not {type(value).__name__})")
            validated = self._wrap_object(value)
            super().__setitem__(index, validated)
    
    def append(self, obj: ObjectType, *, bypass_validation: bool = False, import_mode: bool = False):
        """Validate and append an object."""
        obj = obj if bypass_validation else self._wrap_object(obj)
        super().append(obj)
        if not import_mode:
            self.added_objects.append(obj)
    
    def insert(self, index: SupportsIndex, obj: ObjectType):
        """Validate and insert an object at index."""
        if self._live_editor_mode:
            raise RuntimeError("Direct item editing is not allowed in live editor mode")
        wrapped = self._wrap_object(obj)
        super().insert(index, wrapped)
        self.added_objects.append(wrapped)
    
    def extend(self, iterable: list[ObjectType]):  # type: ignore[override]
        """Validate and extend with multiple objects."""
        validated = [self._wrap_object(obj) for obj in iterable]
        super().extend(validated)
        self.added_objects.extend(validated)
    
    def __add__(self, other: object) -> "ObjectList":  # type: ignore[override]
        """Disabled: use extend() instead for efficiency."""
        raise NotImplementedError("Use .extend() instead of + operator")
    
    def __iadd__(self, other: object) -> "ObjectList":  # type: ignore[override]
        """Disabled: use extend() instead for efficiency."""
        raise NotImplementedError("Use .extend() instead of += operator")
