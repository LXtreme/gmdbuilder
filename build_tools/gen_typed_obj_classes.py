#!/usr/bin/env python3
"""
Step 3: Generate TypedDict classes (with inheritance) from:
- nested enum mapping file (output of step 1)
- TSV type map (output of step 2)
- destination python file containing an AUTOGENERATED block delimited by '# Start' and '# End'

Usage:
  python gen_typed_obj_classes.py ENUMS_PY TYPEMAP_TSV OUT_PY

Important behavior:
- TypedDict FIELD NAMES are the enum VALUES (e.g. a1, a2, a51), not the enum labels (ID, X, ...).
- Enum label names are kept only as comments for readability.
- внутри (within) each enum class, multiple labels may map to the same raw key (aliases).
  We dedupe by raw key so TypedDict doesn't contain duplicates.
"""

from __future__ import annotations

import argparse
import ast
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional


# ----------------------------
# Data model
# ----------------------------

@dataclass
class EnumNode:
    name: str
    # members: (raw_key, primary_label, all_labels)
    # raw_key like 'a51'
    members: list[tuple[str, str, list[str]]] = field(default_factory=list)
    children: list["EnumNode"] = field(default_factory=list)


# ----------------------------
# TSV parsing
# ----------------------------

def read_tsv_types(tsv_path: Path) -> dict[str, str]:
    """
    Reads TSV with columns: key, type, labels
    Returns mapping: {"123": "float|int", ...}
    Blank type -> "".
    """
    out: dict[str, str] = {}
    if not tsv_path.exists():
        return out

    lines = tsv_path.read_text(encoding="utf-8", errors="replace").splitlines()
    for idx, line in enumerate(lines):
        if not line.strip():
            continue
        parts = line.split("\t")
        if len(parts) < 2:
            continue

        key = parts[0].strip()
        typ = parts[1].strip()

        # optional header row
        if idx == 0 and key.lower() in {"key", "id", "number"}:
            continue

        if key.isdigit():
            out[key] = typ

    return out


# ----------------------------
# Enum parsing (AST)
# ----------------------------

def base_name(expr: ast.expr) -> str:
    if isinstance(expr, ast.Name):
        return expr.id
    if isinstance(expr, ast.Attribute):
        return expr.attr
    return ""


def is_enumish_class(cls: ast.ClassDef) -> bool:
    """
    Accept Enum-like bases: Enum, IntEnum, StrEnum, Flag, IntFlag, or anything ending with Enum/Flag.
    Also accept plain classes (no bases) to support simple namespace classes.
    """
    # Accept classes with no bases (plain classes)
    if not cls.bases:
        return True
    
    for b in cls.bases:
        bn = base_name(b)
        if not bn:
            continue
        if bn in {"Enum", "IntEnum", "StrEnum", "Flag", "IntFlag"}:
            return True
        if bn.endswith("Enum") or bn.endswith("Flag"):
            return True
    return False


def valid_identifier(s: str) -> bool:
    return s.isidentifier()


def parse_enum_file(enums_py: Path) -> EnumNode:
    """
    Parses nested Enum classes and builds an EnumNode tree.
    Picks the first top-level Enum-ish class as the root.
    If no top-level class exists, creates a synthetic root from module-level assignments.

    Deduplication:
    - Within each Enum class, multiple labels may map to the same raw_key string (aliases).
    - We keep exactly one TypedDict field per raw_key.
    - We store the first label as primary_label, and keep a list of all alias labels for comment use.
    """
    src = enums_py.read_text(encoding="utf-8", errors="replace")
    tree = ast.parse(src)

    def build_from_class(cls: ast.ClassDef) -> EnumNode:
        node = EnumNode(name=cls.name)

        # raw_key -> list of labels (encounter order)
        alias_map: dict[str, list[str]] = {}

        def consider_member(label_name: str, raw_key: str) -> None:
            if not raw_key:
                return
            # TypedDict field names must be identifiers
            if not valid_identifier(raw_key):
                return
            # enum label is just for comments; should be identifier but keep safe
            if not valid_identifier(label_name):
                return

            alias_map.setdefault(raw_key, []).append(label_name)

        # Collect members directly in this class body (exclude nested class defs)
        for item in cls.body:
            if isinstance(item, ast.ClassDef):
                continue

            # NAME = <value>
            if isinstance(item, ast.Assign) and len(item.targets) == 1 and isinstance(item.targets[0], ast.Name):
                label_name = item.targets[0].id
                val = item.value
                if isinstance(val, ast.Constant) and isinstance(val.value, str):
                    consider_member(label_name, val.value)

            # NAME: T = <value>
            if isinstance(item, ast.AnnAssign) and isinstance(item.target, ast.Name) and item.value is not None:
                label_name = item.target.id
                val = item.value
                if isinstance(val, ast.Constant) and isinstance(val.value, str):
                    consider_member(label_name, val.value)

        # Convert alias map -> node.members (stable order by first appearance in file)
        # We preserve encounter order by scanning cls.body again and adding keys the first time we see them.
        seen_keys_in_order: list[str] = []
        seen_set: set[str] = set()

        def maybe_add_key(raw_key: str) -> None:
            if raw_key in seen_set:
                return
            seen_set.add(raw_key)
            seen_keys_in_order.append(raw_key)

        for item in cls.body:
            if isinstance(item, ast.ClassDef):
                continue
            if isinstance(item, ast.Assign) and len(item.targets) == 1 and isinstance(item.targets[0], ast.Name):
                val = item.value
                if isinstance(val, ast.Constant) and isinstance(val.value, str):
                    rk = val.value
                    if rk in alias_map:
                        maybe_add_key(rk)
            if isinstance(item, ast.AnnAssign) and item.value is not None:
                val = item.value
                if isinstance(val, ast.Constant) and isinstance(val.value, str):
                    rk = val.value
                    if rk in alias_map:
                        maybe_add_key(rk)

        for rk in seen_keys_in_order:
            labels = alias_map[rk]
            primary = labels[0]
            node.members.append((rk, primary, labels))

        # Recurse into nested Enum-ish classes
        for item in cls.body:
            if isinstance(item, ast.ClassDef) and is_enumish_class(item):
                node.children.append(build_from_class(item))

        return node

    # Create a synthetic root from module-level assignments and classes
    # This handles flat file structures where properties are at module level
    root = EnumNode(name="ObjProp")
    
    # raw_key -> list of labels (encounter order)
    alias_map: dict[str, list[str]] = {}

    def consider_member(label_name: str, raw_key: str) -> None:
        if not raw_key:
            return
        if not valid_identifier(raw_key):
            return
        if not valid_identifier(label_name):
            return
        alias_map.setdefault(raw_key, []).append(label_name)

    # Collect module-level assignments
    for item in tree.body:
        if isinstance(item, ast.Assign) and len(item.targets) == 1 and isinstance(item.targets[0], ast.Name):
            label_name = item.targets[0].id
            val = item.value
            if isinstance(val, ast.Constant) and isinstance(val.value, str):
                consider_member(label_name, val.value)
        
        if isinstance(item, ast.AnnAssign) and isinstance(item.target, ast.Name) and item.value is not None:
            label_name = item.target.id
            val = item.value
            if isinstance(val, ast.Constant) and isinstance(val.value, str):
                consider_member(label_name, val.value)

    # Convert to members
    seen_keys_in_order: list[str] = []
    seen_set: set[str] = set()

    def maybe_add_key(raw_key: str) -> None:
        if raw_key in seen_set:
            return
        seen_set.add(raw_key)
        seen_keys_in_order.append(raw_key)

    for item in tree.body:
        if isinstance(item, ast.Assign) and len(item.targets) == 1 and isinstance(item.targets[0], ast.Name):
            val = item.value
            if isinstance(val, ast.Constant) and isinstance(val.value, str):
                rk = val.value
                if rk in alias_map:
                    maybe_add_key(rk)
        if isinstance(item, ast.AnnAssign) and item.value is not None:
            val = item.value
            if isinstance(val, ast.Constant) and isinstance(val.value, str):
                rk = val.value
                if rk in alias_map:
                    maybe_add_key(rk)

    for rk in seen_keys_in_order:
        labels = alias_map[rk]
        primary = labels[0]
        root.members.append((rk, primary, labels))

    # Add nested classes as children
    for item in tree.body:
        if isinstance(item, ast.ClassDef) and is_enumish_class(item):
            root.children.append(build_from_class(item))

    return root


# ----------------------------
# TypedDict generation
# ----------------------------

def extract_numeric_id(raw_key: str, prefix: str) -> Optional[str]:
    """
    raw_key: 'a123'
    returns '123' if matches prefix+digits, else None
    """
    if not raw_key.startswith(prefix):
        return None
    rest = raw_key[len(prefix):]
    if rest.isdigit():
        return rest
    return None


def format_comment(primary: str, aliases: list[str]) -> str:
    """
    Comment style:
    - If no aliases: "# NAME"
    - If aliases: "# NAME (ALIASED: A, B, C)" or shorter
    """
    if not aliases or len(aliases) == 1:
        return f"# {primary}"
    # keep it readable; include all aliases
    others = ", ".join(aliases[1:])
    return f"# {primary} (ALIASES: {others})"


def emit_typeddict_classes(
    root: EnumNode,
    tsv_types: dict[str, str],
    prefix: str,
    root_typeddict_name: str,
    include_other_strings: bool,
) -> str:
    """
    Generates TypedDict classes with inheritance mirroring enum nesting.

    Root enum class becomes root_typeddict_name (default: Object)
    Child classes keep their enum class names (Trigger, Move, etc.)

    Field names are raw enum values (a123), not enum labels.
    """
    lines: list[str] = []

    def walk(node: EnumNode, parent_td_name: Optional[str]) -> None:
        td_name = root_typeddict_name if parent_td_name is None else node.name + "Type"
        base_clause = "TypedDict" if parent_td_name is None else parent_td_name

        # Collect fields first to check if we have any
        fields_to_emit: list[str] = []
        for raw_key, primary_label, aliases in node.members:
            num = extract_numeric_id(raw_key, prefix)

            if num is None:
                if not include_other_strings:
                    continue
                typ = "Any"
            else:
                typ = tsv_types.get(num, "").strip() or "Any"

            comment = format_comment(primary_label, aliases)
            fields_to_emit.append(f"    {raw_key}: {typ}  {comment}")

        # Only emit class if it has fields
        if fields_to_emit:
            lines.append(f"class {td_name}({base_clause}, total=False):")
            for field in fields_to_emit:
                lines.append(field)
            lines.append("")

        # Walk children regardless of whether parent was emitted
        for child in node.children:
            walk(child, td_name)

    walk(root, parent_td_name=None)

    while lines and not lines[-1].strip():
        lines.pop()

    return "\n".join(lines) + "\n"


# ----------------------------
# Autogenerated block replacement
# ----------------------------

START_MARK = "# Start"
END_MARK = "# End"

AUTO_HEADER = """# ======================================================================
#   AUTOGENERATED TYPEDDICT
# ======================================================================
"""


def replace_autogen_block(existing: str, generated_block: str) -> str:
    """
    Replaces content between '# Start' and '# End' (markers remain).
    If markers not found, appends a fresh block at the end.
    """
    if START_MARK in existing and END_MARK in existing:
        pre, rest = existing.split(START_MARK, 1)
        _, post = rest.split(END_MARK, 1)
        return pre + START_MARK + "\n" + generated_block + "\n" + END_MARK + post

    if existing and not existing.endswith("\n"):
        existing += "\n"
    return (
        existing
        + "\n"
        + AUTO_HEADER
        + START_MARK
        + "\n"
        + generated_block
        + "\n"
        + END_MARK
        + "\n"
    )


def ensure_file_skeleton_if_missing(out_py: Path) -> str:
    """
    If output doesn't exist, create a minimal manual section.
    """
    if out_py.exists():
        return out_py.read_text(encoding="utf-8", errors="replace")

    return (
        "from __future__ import annotations\n"
        "\n"
        "from typing import Any, TypedDict\n"
        "\n"
        "# Put your custom imports and custom types above the autogenerated section.\n"
        "\n"
    )


# ----------------------------
# Main
# ----------------------------

def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("enums_py", type=Path, help="Enum mapping python file (step 1 output)")
    ap.add_argument("typemap_tsv", type=Path, help="TSV type map file (step 2 output)")
    ap.add_argument("out_py", type=Path, help="Destination python file to write/patch")
    ap.add_argument("--prefix", default="a", help='Prefix used in enum values (default: "a")')
    ap.add_argument("--root-name", default="Object", help='Name for the root TypedDict (default: "Object")')
    ap.add_argument(
        "--include-other-strings",
        action="store_true",
        help="Include enum members whose value is a string not matching prefix+digits (typed as Any).",
    )
    args = ap.parse_args()

    if not args.enums_py.exists():
        raise SystemExit(f"Enum file not found: {args.enums_py}")
    if not args.typemap_tsv.exists():
        raise SystemExit(f"TSV type map not found: {args.typemap_tsv}")

    tsv_types = read_tsv_types(args.typemap_tsv)
    enum_root = parse_enum_file(args.enums_py)

    generated = emit_typeddict_classes(
        root=enum_root,
        tsv_types=tsv_types,
        prefix=args.prefix,
        root_typeddict_name=args.root_name,
        include_other_strings=args.include_other_strings,
    )

    existing_text = ensure_file_skeleton_if_missing(args.out_py)
    new_text = replace_autogen_block(existing_text, generated)

    args.out_py.parent.mkdir(parents=True, exist_ok=True)
    args.out_py.write_text(new_text, encoding="utf-8")

    print(f"Wrote TypedDicts to: {args.out_py}")


if __name__ == "__main__":
    main()
